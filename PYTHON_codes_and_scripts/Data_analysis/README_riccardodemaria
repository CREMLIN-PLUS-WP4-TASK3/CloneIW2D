# to launch python interactively with all pylab functions:

ipython -pylab

# then, in ipython, to use Riccardo's class for ADT data:


from multiturndata_riccardodemaria import *

t=MultiTurnData("/home/nmounet/Documents/Mesures_LHC/MD_08052011_coupledbunch_instab/ADT/ADT-pickups-Beam2-08-May-2011_17-54-07.data")


# then for example:

t.ADTBposVerQ9LB2.plotPos(0)

t.ADTBposVerQ9LB2.plotPos(7)

for i in arange(7): t.ADTBposVerQ9RB1.plotPos(i);



# for sddsdata:

from sddsdata_riccardodemaria import *

t=sddsdata("/home/nmounet/Documents/Mesures_LHC/MD_08052011_coupledbunch_instab/LHC-BPM/BunchTurn_data/Beam2@BunchTurn@2011_05_08@11_18_05_876.sdds")

# to look at the parameters and data names in t: just type

t

# everything is in t.data, which is aranged by pages (usually only page 0 is used at CERN -> everything in t.data[0])
t.data[0]



# for LHC-BPM sdds data (bunchturn data):

# bunches in e.g.
t.data[0]['verBunchId']

# for LHC-BPM (bunchturn data): positions in e.g.
t.data[0]['horPositionsConcentratedAndSorted']

# shape obtained from e.g.:
t.data[0]['horPositionsConcentratedAndSorted'].shape

# nb of turns, bunches and bpms
nbTurn=t.data[0]['nbOfCapTurns'][0]
nbBunch=t.data[0]['nbOfCapBunches'][0]
nbpm=t.data[0]['bpmNames'].shape[0]

# data have nbpm*nbTurn*nbBunch elements. First are written all data (nbTurn*nbBunch) from bpm #1, then bpm #2, etc.
# most bpms give zero data

# to use Sussix:
from numpy import *
sys.path.append("SUSSIX")
sys.path.append("SUSSIX/Sussix")
from SussixNM import *

# in the following i is bpm number, j is bunch number
i=0;j=0;x2=t.data[0]['horPositionsConcentratedAndSorted'][i*nbTurn*nbBunch+j*nbTurn:i*nbTurn*nbBunch+(j+1)*nbTurn];plot(x2);
i=3;j=0;y2=t.data[0]['verPositionsConcentratedAndSorted'][i*nbTurn*nbBunch+j*nbTurn:i*nbTurn*nbBunch+(j+1)*nbTurn];plot(y2);
sussix_inp(ir=1, turns=nbTurn, tunex=0.28, tuney=0.31, tunez=0.005, istun=0.02, idam=2, narm=300)
a=sussixBS(x2,y2,zeros(len(x2)),zeros(len(y2)));

# tunes:
a.tunexy

# to plot spectra:
dicx=dict(transpose([a.ox,a.ax]));dicy=dict(transpose([a.oy,a.ay]));
semilogy(sort(a.ox),[dicx[i] for i in sort(a.ox)]);
semilogy(sort(a.oy),[dicy[i] for i in sort(a.oy)]);

# turn by turn (k is turn number)
i=0;k=0;plot(t.data[0]['horPositionsConcentratedAndSorted'][i*nbTurn*nbBunch+k:(i+1)*nbTurn*nbBunch:nbTurn]);
i=3;k=0;plot(t.data[0]['verPositionsConcentratedAndSorted'][i*nbTurn*nbBunch+k:(i+1)*nbTurn*nbBunch:nbTurn]);

# to make an animated gif:
import os, sys
files = []
fig = figure(facecolor='w', edgecolor=None);
ax = fig.gca();
for k in range(0,nbTurn,5):
    ax.cla()
    i=3;
    ax.plot(t.data[0]['verPositionsConcentratedAndSorted'][i*nbTurn*nbBunch+k:(i+1)*nbTurn*nbBunch:nbTurn]); # position
    ax.set_ylim([-2,2]);
    fname = '_tmp%03d.png'%k
    print 'Saving frame', fname
    fig.savefig(fname)
    files.append(fname)
print 'Making movie animation.gif - this make take a while'
os.system("convert *.png animation.gif")
os.system("rm *.png")


# headtail monitor
h=sddsdata("/home/nmounet/Documents/Mesures_LHC/MD_08052011_coupledbunch_instab/headtail/HeadTail_B2_2011-05-08_131806_SC#0.sdds.gz")

h.data[0]

#nb turns (note: in 100musec mode, data is not taken every turn but every 2 or 3 turns):
nbTurn=int(h.data[0]['frameCount'])

# number of points per turn
nbPts=int(h.data[0]['frLenSamples'])

# plot delta signal
for i in range(nbTurn):plot(h.data[0]['rawDelta'][i*nbPts:(i+1)*nbPts])

# plot sum signal
for i in range(nbTurn):plot(h.data[0]['rawSum'][i*nbPts:(i+1)*nbPts])


# to make an animated gif:
import os, sys
files = []
fig = figure(facecolor='w', edgecolor=None);
ax = fig.gca();
for i in range(nbTurn):
    ax.cla()
    ax.plot(h.data[0]['rawDelta'][i*nbPts:(i+1)*nbPts]/h.data[0]['rawSum'][i*nbPts:(i+1)*nbPts]) # position
    #ax.plot(h.data[0]['rawDelta'][i*nbPts:(i+1)*nbPts])
    ylim([-20,30]);
    xlim([24000,43000]); # zoom on 36 bunches
    #xlim([42130,42150]); # zoom on last of 36 bunches (excluding reflexion)
    #xlim([9000,16000]); # zoom on 12 bunches
    fname = '_tmp%03d.png'%i
    print 'Saving frame', fname
    fig.savefig(fname)
    files.append(fname)
print 'Making movie animation.gif - this make take a while'
os.system("convert *.png animation.gif")
os.system("rm *.png")

