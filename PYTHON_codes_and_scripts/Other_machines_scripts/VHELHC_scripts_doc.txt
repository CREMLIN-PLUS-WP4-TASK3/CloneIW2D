#########################################################################################
#########################################################################################
#											#
#	Some basic info about Lepton machines functions and scripts			#
#											#
#########################################################################################
#########################################################################################


#################################################################################
# Some function defined here (providing parameters)				#
#################################################################################


FILE
    VHELHC_aperture_scan.py

FUNCTIONS
    VHELHC_param(E=50e12, Qxfrac=0.9, Qyfrac=0.9, V=16e6)
        generate typical VHELHC parameters, from the beam energy E in eV, the fractional parts of the tunes and the RF voltage in V.
	Outputs:
	- machine: string with machine name(here 'TLEP'+option),
	- E: same as input (beam energy in eV),
	- gamma: relativistic mass factor,
	- sigmaz: RMS bunch length in m,
	- taub: total bunch length in s (4*RMS),
	- R: machine pysical radius (circumference/(2 pi)),
	- Qx: total horizontal tune (integer + fractional parts),
	- Qxfrac: fractional horizontal tune,
	- Qy: total vertical tune (integer + fractional parts),
	- Qyfrac: fractional vertical tune,
	- Qs: synchrotron tune,
	- eta: slippage factor (alpha_p-1/gamma^2),
	- f0: revolution frequency,
	- omega0: revolution angular frequency=2pi*f0,
	- omegas: synchrotron angular frequency=Qs*omega0,
	- dphase: phase of damper w.r.t. "normal" purely resistive damper (0),
	- Estr: string with energy (e.g. '50TeV').
    

#################################################################################
# Script examples
#################################################################################

# All python files here are scripts that can be run from the command line,
# performing certain kinds of Impedance and/or DELPHI computations.
#
# They have to be taken as mere examples; in particular, the oldest ones 
# do not use the latest and highest level DELPHI wrapping functions and can be quite
# inefficient, or even crash.

# In principle a new script has to be done for any new kind of computation, and these
# examples can serve as starting points.

# If one wants to launch a test, you can try the script VHELLHC_aperture_scan.py
#(see description below)

# To launch the scripts on a LSF batch system (like lxplus), the procedure is
# (e.g. here with VHELLHC_aperture_scan.py):
# first type
./VHELLHC_aperture_scan.py launch launch
#
# -> this launches the resistive-wall impedance computations on batch jobs (here of collimators)
#
# then when all jobs are finished (and if none crashed)
./VHELLHC_aperture_scan.py retrieve launch
#
# -> this retrieves the resistive-wall impedance computations, computes the impedance model
#  and finally launches the DELPHI computations
# to get instabilities complex tune shifts. Note that if some computations were already done
# (in a previous 'launch'), only computations that were not already performed
# (i.e. for which there is not the file 'outpickle_[name_of_the_computation]' already
# present in the 'root_result' folder - see below) are launched.
#
# Finally, when all jobs are finished: 
./VHELLHC_aperture_scan.py retrieve retrieve
#
# -> this will finally write output files and plots (depending on the scripts).
#
# Note: sometimes there will be a warning, saying that some 'outpickle[...]' file is missing
# The code can still retrieve the results (there will simply be some missing points in the plots...).
# So it is a problem only if too many of such warnings happen, which would mean there is
# a more serious issue (e.g. queue on lxbatch is too short, or computations failed for
# some reason).

# In all these scripts results are put in the folder 'root_result', that is most of the time: 
# ../../../DELPHI_results/[machine_name]/[some_name_related_to_the_script]
# You can change this folder at the beginning of the script.

# Scripts are ~always structured as followed:
# - parameters and scanned parameters definition
# - impedance model computation
# - DELPHI computation (sometimes with Sacherer also)
# - plots of results (typically growth_rate vs Q' or vs. intensity, TMCI plots, etc.).

##########
# Typical variables that are very often used (see also parameters described above in [machine]_param functions)
# in these scripts examples:

- root_result: directory where to put the results
- flagnorm (always 0): 1 if damper matrix normalized at current chromaticity; 0
  if instead it is normalized at zero chroma (which I almost always assume)
- strnorm (always ['','_norm_current_chroma']): (this never changes...) list with 2 strings:
  at the end of all output files, the string strnorm[flagnorm] is added (it is more or less useless...)
- flagsave: 1 to save figures in .png and .eps files, instead of plotting on screen (0 to plot on screen 
  -> very dangerous since there can be many many plots...)
- flagSach: 1 to launch Sacherer computations also (done locally and sequentially,
so takes lots of time), 0 otherwise (then will look for file 
'Sacherer[...].txt' in root_result)
- flagdamperimp: 1 to use frequency dependent damper gain (that you have to provide in Zd,fd),
  0 to use a bunch-by-bunch damper
- wake_calc: True -> compute wake as well (otherwise only impedance)
- kmax: number of converged eigenvalues in DELPHI convergence process (kmax most unstable ones are 
converged within at worst 5%) -> kmax=1 is enough when we look only at most unstable mode
- kmaxplot: number of kept and plotted eigenvalues (in TMCI plot)
- lmaxSach: maximum headtail mode considered for Sacherer computations
- g,a,b: longitudinal distribution parameters, usually from longdistribution_decomp function (from DELPHI.py) 

- typical scan definition:
    
    Scans on beam & machine parameters (all these scans are typically done on top of each others ->
    can make up many many calculations - but remember that intensity scan, damper gain and phase scans, and Qs scans
    take no time)
    * materialscan & scenarioscan: scan on kind of material for vacuum pipe
    * hgapscan: scan on vacuum pipe half-gap (aperture) [m]
    * coatscan: scan in coating thickness [m]
    * Qpscan: scan in chromaticity
    * dampscan: damper gain scan (in 1/number_of_damping_turns)
    * Nbscan: intensity scan (number of particles per bunch)
    * Nbscanplot: intensities for which we do plots vs Qp
    * Mscan: scan on total number of bunches.


- tuneshiftQp: array of complex tuneshifts with all DELPHI results, for all scanned parameters and all kmaxplot modes kept
- tuneshiftm0Qp: array of complex tuneshifts for mode 0 only, for all scanned parameters
- tuneshiftQpSach: array of complex tuneshifts computed using Sacherer formula, for all scanned parameters
- tuneshiftQpSachm0: same as above but mode 0 only
- imp_mod: full impedance model (list of components, which are impedance_wake objects from the
impedance library in Impedance.py)
- imp_mod_list: complete list of impedance scenarios (list of impedance models)
- wake_mod & wake_mod_list: same but for wake functions.


###########
# Short description of each script


    VHELHC_aperture_scan.py
    	Perform a scan in aperture of the beam pipe and a scan in temperature of the beam screens (plain Cu),
	to get different resistive-wall impedance models for VHE-LHC (parameters from
	D. Schulte), and compute in each case the complex tuneshifts vs Q' from DELPHI and Sacherer, and TMCI thresholds.

    VHELHC_coating_scan.py
    	Perform a scan in Cu-coating thickness of the beam screens and a scan in their temperature,
	to get different resistive-wall impedance models for VHE-LHC (parameters from
	D. Schulte), and compute in each case the complex tuneshifts vs Q' from DELPHI and Sacherer, and TMCI thresholds.


