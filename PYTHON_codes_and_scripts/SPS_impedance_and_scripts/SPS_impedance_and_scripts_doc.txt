#########################################################################################
#########################################################################################
#											#
#	Some basic info about SPS functions and scripts					#
#											#
#########################################################################################
#########################################################################################


#################################################################################
# SPS parameters & settings								#
#################################################################################

###########
# function to provide general SPS parameters

FILE
    SPS_param.py

FUNCTIONS
    SPS_param(E0, E=26e9, optics='Q26')
    
	generate typical SPS parameters, given the proton rest energy E0 in J (from e.g. function
	proton_param), the beam energy E in eV and the kind of optics ('Q20' or 'Q26').
	Outputs:
	- machine: string with machine name,
	- E: same as input (beam energy in eV),
	- gamma: relativistic mass factor,
	- sigmaz: RMS bunch length in m,
	- taub: total bunch length in s (4*RMS),
	- R: machine pysical radius (circumference/(2 pi)),
	- Qx: total horizontal tune (integer + fractional parts),
	- Qxfrac: fractional horizontal tune,
	- Qy: total vertical tune (integer + fractional parts),
	- Qyfrac: fractional vertical,
	- Qs: synchrotron tune,
	- eta: slippage factor (alpha_p-1/gamma^2),
	- f0: revolution frequency,
	- omega0: revolution angular frequency=2pi*f0,
	- omegas: synchrotron angular frequency=Qs*omega0,
	- dphase: phase of damper w.r.t. "normal" purely resistive damper,
	- Estr: string with energy (e.g. '26GeV', '450GeV').
    
#############
# Folders imp_model_SPS_from_CZannini and Coll_settings

# Those are folders containing resp. the SPS impedance models from Carlo Zannini
# (for various optics options, and with different degrees of refinement
# of the model) and some collimator settings for the LAGUNA experiment.


#################################################################################
# Script examples
#################################################################################

# All the other python files here are scripts that can be run from the command line,
# performing certain kinds of Impedance and/or DELPHI computations.
#
# They have to be taken as mere examples; in particular, the oldest ones 
# do not use the latest and highest level DELPHI wrapping functions and can be quite
# inefficient, or even crash. For instance, some might look for HEADTAIL simulation
# files which are local files in N. Mounet workspace; you have to comment/take out
# the corresponding lines (see also below).

# In principle a new script has to be done for any new kind of computation, and these
# examples can serve as starting points.

# If one wants to launch a test, a recent script that should work is
SPS_conv_LHC_LAGUNA_collimators.py
#(see description below)

# To launch the scripts on a LSF batch system (like lxplus), the procedure is
# (e.g. here with SPS_conv_LHC_LAGUNA_collimators.py):
# first type
./SPS_conv_LHC_LAGUNA_collimators.py launch launch
#
# -> this launches the resistive-wall impedance computations on batch jobs (here of collimators)
#
# then when all jobs are finished (and if none crashed)
./SPS_conv_LHC_LAGUNA_collimators.py retrieve launch
#
# -> this retrieves the resistive-wall impedance computations, computes the impedance model
#  and finally launches the DELPHI computations
# to get instabilities complex tune shifts. Note that if some computations were already done
# (in a previous 'launch'), only computations that were not already performed
# (i.e. for which there is not the file 'outpickle_[name_of_the_computation]' already
# present in the 'root_result' folder - see below) are launched.
#
# Finally, when all jobs are finished: 
./SPS_conv_LHC_LAGUNA_collimators.py retrieve retrieve
#
# -> this will finally write output files and plots (depending on the scripts).
#
# Note: sometimes there will be a warning, saying that some 'outpickle[...]' file is missing
# The code can still retrieve the results (there will simply be some missing points in the plots...).
# So it is a problem only if too many of such warnings happen, which would mean there is
# a more serious issue (e.g. queue on lxbatch is too short, or computations failed for
# some reason).

# In all these scripts results are put in the folder 'root_result', that is most of the time: 
# ../../../DELPHI_results/[machine_name]/[some_name_related_to_the_script]
# You can change this folder at the beginning of the script.

# Scripts are ~always structured as followed:
# - parameters and scanned parameters definition
# - impedance model computation
# - DELPHI computation (sometimes with Sacherer also)
# - plots of results (typically growth_rate vs Q' or vs. intensity, TMCI plots, etc.).

##########
# Typical variables that are very often used (see also SPS parameters described above in SPS_param function)
# in these scripts examples:

- root_result: directory where to put the results
- flagnorm (always 0): 1 if damper matrix normalized at current chromaticity; 0
  if instead it is normalized at zero chroma (which I almost always assume)
- strnorm (always ['','_norm_current_chroma']): (this never changes...) list with 2 strings:
  at the end of all output files, the string strnorm[flagnorm] is added (it is more or less useless...)
- flagsave: 1 to save figures in .png and .eps files, instead of plotting on screen (0 to plot on screen 
  -> very dangerous since there can be many many plots...)
- flagdamperimp (always 0): 1 to use frequency dependent damper gain (that you have to provide in Zd,fd),
  0 to use a bunch-by-bunch damper
- flagplotQp: 1 to plot scans vs Q' (or csi) 
- flagSach: 1 to launch Sacherer computations also (done locally and sequentially,
so takes lots of time), 0 otherwise (then will look for file 
'Sacherer[...].txt' in root_result)
- wake_calc: True -> compute wake as well (otherwise only impedance)
- kmax: number of converged eigenvalues in DELPHI convergence process (kmax most unstable ones are 
converged within at worst 5%) -> kmax=1 is enough when we look only at most unstable mode
- kmaxplot: number of kept and plotted eigenvalues (in TMCI plot)
- lmaxSach: maximum headtail mode considered for Sacherer computations
- g,a,b: longitudinal distribution parameters, usually from longdistribution_decomp function (from DELPHI.py) 

- typical scan definition:
    
    Scans on impedance model parameters (all these scans have same length -> all arrays are corresponding
    to each others):
    * scenarioscan: scan on impedance model or string to be added to outputs for each scanned scenario
    * modelscan: scan on impedance model
    * collscan: scan on presence of collimator (for LAGUNA)
    * opticscan: scan on kind of optcis (Q20, Q26)
    * legscen: legends corresponding to scenarioscan
    
    Scans on beam & machine parameters (all these scans are typically done on top of each others ->
    can make up many many calculations - but remember that intensity scan, damper gain and phase scans, and Qs scans
    take no time)
    * Escan: scan on beam energy (injection, top energy)
    * csiscan: scan in chromaticity
    * csiplotscan: chromaticities for which we do plot vs intensity and/or TMCI plots 
    * dampscan: damper gain scan (in 1/number_of_damping_turns)
    * Nbscan: intensity scan (number of particles per bunch)
    * Nbscanplot: intensities for which we do plots vs Qp
    * NbscanHEADTAIL[...]: intensities for which we do a comparison vs HEADTAIL
    NOTE: this typically requires access to N. Mounet local files, so you have to deactivate this by 
    making the array empty
    * Mscan: scan on total number of bunches.


- tuneshiftQp: array of complex tuneshifts with all DELPHI results, for all scanned parameters and all kmaxplot modes kept
- tuneshiftQpSach: array of complex tuneshifts computed using Sacherer formula, for all scanned parameters
- tuneshiftQpSachm0: same as above but mode 0 only
- ZeffSach: array of complex effective impedance computed using Sacherer formula, for all scanned parameters
- imp_mod: full impedance model (list of components, which are impedance_wake objects from the
impedance library in Impedance.py)
- imp_mod_list: complete list of impedance scenarios (list of impedance models)
- wake_mod and wake_mod_list: same but for wake functions.


###########
# Short description of each script

# NOTE: in all cases except for SPS_conv_LHC_LAGUNA_collimators.py,
# the first launch is useless and one can do right away
# ./[script_name] retrieve launch
#
# For the last script (SPS_conv_TMCI_Q20.py) there is even only
# one retrieve/launch:
# ./SPS_conv_TMCI_Q20.py launch
# or
# ./SPS_conv_TMCI_Q20.py retrieve


    SPS_conv_LHC_LAGUNA_collimators.py
    	Perform complex tunesfhits and TMCI threshold computation for the LAGUNA
	configuration, with/without collimators, for all optcis and energies

    SPS_conv.py
    	Simple script to compute growth rates vs Q' and TMCI threshold
	from the SPS impedance model

    SPS_conv_TMCI_BB_test.py
    	Growth rates vs Q' and TMCI computation on a very simple SPS model
	(single broad-band resonator)

    SPS_conv_TMCI_Q20.py  	(launch with ./SPS_conv_TMCI_Q20.py launch)
	Growth rates vs Q' and TMCI computation from the SPS impedance model.

