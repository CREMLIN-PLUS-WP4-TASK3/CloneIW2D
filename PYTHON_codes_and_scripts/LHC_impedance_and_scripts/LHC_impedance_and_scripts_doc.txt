#########################################################################################
#########################################################################################
#											#
#	Some basic info about LHC functions and scripts					#
#											#
#########################################################################################
#########################################################################################


#################################################################################
# LHC & HL-LHC impedance model generating functions				#
#################################################################################

# help on all LHC & HL-LHC subroutines generating the impedance models
# in LHC_coll_imp.py, LHC_imp.py, HLLHC_imp.py

#########
# LHC_imp

# library of functions to compute the impedance of the LHC
#
# most useful functions:
#    LHC_imp_model_v1: computes the initial version of the model (simple and relatively fast)
#    LHC_imp_model_v2: computes the updated version of the model (more complicated but more accurate)

FILE
    LHC_imp.py

FUNCTIONS
    LHC_imp_model_v1(E, avbetax, avbetay, param_filename_coll, settings_filename_coll, beta_filename_coll=None, dire='/afs/cern.ch/user/n/nmounet/scratch0/GIT_IRIS/IR...d_scripts/LHC_impedance_and_scripts/LHC_elements/', commentcoll='', direcoll='Coll/', lxplusbatch=None, beam='1', squeeze='0p6m_3m_0p6m_3m', wake_calc=False, ftypescan=0, nflog=100, zpar=<Impedance.z_param object>, flagplot=False, root_result='/afs/cern.ch/user/n/nmounet/scratch0/GIT_IRIS/IR...impedance_and_scripts/../../../DELPHI_results/LHC', commentsave='')
        Total LHC impedance model as of 2012 -> oct. 2013
        - E: particle energy in eV
        - avbetax, avbetay: average beta function from smooth approximation (R/Q) in m
        - param_filename_coll: file with collimator parameters (including materials, 
        angle, length, beta functions)
        - settings_filename_coll: collimator settings file
        - beta_filename_coll: collimator beta functions file (if present - otherwise take param_filename_coll)
        - dire: directory where to find all files with parameters for the rest of the machine
        - commentcoll: comment for the collimators IW2D computation
        - direcoll: subdirectory of ImpedanceWake2D where to put collimators impedance
        - lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus
                       if 'retrieve' -> retrieve outputs
        - beam: beam number ('1' or '2')
        - squeeze: suffix of filename with beta functions, for the rest of the 
        machine (everything except collimators). The first number gives the squeeze in IP1, 
        from which the broad-band impedance (from design report) is evaluated (squeezed if <2m,
        otherwise injection BB model is taken)
        - wake_calc: True to compute wake function as well
        - ftypescan, nflog and zpar: parameters for frequency and distance scans
        - flagplot: if True, plot impedances and percent of each part of the model
        - root_result: used only with flagplot: directory where to put impedance plots.
        - commentsave: used only with flagplot: additional comment for filename of impedance plots.
    
    LHC_imp_model_v2(E, avbetax, avbetay, param_filename_coll, settings_filename_coll, beta_filename_coll=None, TDIcoating='preLS1', dire='/afs/cern.ch/user/n/nmounet/scratch0/GIT_IRIS/IR...d_scripts/LHC_impedance_and_scripts/LHC_elements/', commentcoll='', direcoll='Coll_v2/', lxplusbatch=None, BPM=False, beam='1', squeeze='0p6m_3m_0p6m_3m', wake_calc=False, ftypescan=0, nflog=100, zpar=<Impedance.z_param object>, fcutoffBB=50000000000.0, flagplot=False, root_result='/afs/cern.ch/user/n/nmounet/scratch0/GIT_IRIS/IR...impedance_and_scripts/../../../DELPHI_results/LHC', commentsave='', assymetry_factor_TCL6=1.0)
        Total LHC impedance model as of Nov. 2013
        - E: particle energy in eV
        - avbetax, avbetay: average beta function from smooth approximation (R/Q) in m
        - param_filename_coll: file with collimator parameters (including materials, 
          angle, length, beta functions)
        - settings_filename_coll: collimator settings file
        - beta_filename_coll: collimator beta functions file (if present - otherwise take param_filename_coll)
        - TDIcoating: kind of coating for first block of TDI: can be 'preLS1'
          (5mum Ti) or 'postLS1' (1mum NEG + 2mum CU + 0.3mum NEG + 5mum Ti) or 
          directly a list of layer objects
        - dire: directory where to find all files with parameters for the rest of the machine
        - commentcoll: comment for the collimators IW2D computation
        - direcoll: subdirectory of ImpedanceWake2D where to put collimators impedance
        - lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus
                       if 'retrieve' -> retrieve outputs
        - BPM: coll. geometry contains a BPM cavity if BPM is True, otherwise old LHC coll. geometry
        - beam: beam number ('1' or '2')
        - squeeze: suffix of filename with beta functions, for the rest of the 
        machine (everything except collimators). The first number gives the squeeze in IP1, 
        from which the broad-band impedance (from design report) is evaluated (squeezed if <2m,
        otherwise injection BB model is taken)
        - wake_calc: True to compute wake function as well
        - ftypescan, nflog and zpar: parameters for frequency and distance scans,
        - fcutoffBB: cutoff frequency for broad-band models,
        - flagplot: if True, plot impedances and percent of each part of the model,
        - root_result: used only with flagplot: directory where to put impedance plots,
        - commentsave: used only with flagplot: additional comment for filename of impedance plots.
        - assymetry_factor_TCL6: assymetry factor between the distance beam-jaw
        in the case of the TCL6 (1 means that jaws are symmetric - default).
    
    LHC_design_Broadband(squeeze=True, wake_calc=False, fpar=<Impedance.freq_param object>, zpar=<Impedance.z_param object>)
        LHC broad-band model (longitudinal and transverse)
        based on LHC design report (chap. 5)
        two different cases: squeezed optics or injection optics
        fpar and zpar select the frequencies and
        distances (for the wake) scans (objects of the classes freq_param and z_param).
    
    LHC_design_Broadband_less(wake_calc=False, fpar=<Impedance.freq_param object>, zpar=<Impedance.z_param object>, fcutoffBB=5000000000.0)
        LHC broad-band model (longitudinal and transverse)
        based on LHC design report (chap. 5), taking out collimators, pumping slots and RF.
        two different cases: squeezed optics or injection optics
        fpar and zpar select the frequencies and
        distances (for the wake) scans (objects of the classes freq_param and z_param).
        fcutoffBB: cutoff frequency of the broad-band model
    
    LHC_element_iw_model(name, layers, b, w, E, length, orientation, thickness=[], Bfield=None, wake_calc=False, fpar=<Impedance.freq_param object>, zpar=<Impedance.z_param object>, lxplusbatch=None, comment='', dire='')
        construct impedance/wake model for an LHC elliptic element
        name is the name of the element, layers a list of layers or material names,
        b and w the semi-axes (resp. small and large) in m.
        E is the energy in eV.
        orientation:'H' or 'V' for hor. or vert. orientation of b. 
        if material names are given (not layer class object), then layers
        thickness should be given as well in the list 'thickness'.
        Bfield: magnetic field (if None, compute it from the energy with LHC bending radius)
        wake_calc: flag for wake calculation
        
        fpar and zpar select the frequencies and distances (for the wake) scans 
        (objects of the classes freq_param and z_param).
        
        lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus on queue 'queue'
                       if 'retrieve' -> retrieve outputs
        comment is added to the IW2D output file names
        dire contains the directory name where to put the outputs (default='./'=directory of IW2D)
    
    LHC_manyBB_resonator(avbetax, avbetay, param_filename, beta_filename, fcutoff=5000000000.0, Q=1, beta=1, wake_calc=False, namesref=None, fpar=<Impedance.freq_param object>, zpar=<Impedance.z_param object>, power_loss_param=None)
        add up many axisymmetric broad-band resonators into a single model.
        only longitudinal and dipolar terms are considered.
        avbetax and avbetay are the average beta functions
        used for the weighting, param_filename is the file with all parameters
        except betas, beta_filename the file with beta functions (in m).
        fcutoff is the cutoff frequency of the broad-band model (from the beam pipe radius)
        and Q the quality factor chosen (usually 1).
        beta is the relativistic velocity factor
        wake_calc selects the wake computation if True, fpar and zpar select the frequencies and
        distances (for the wake) scans (objects of the classes freq_param and z_param).
        namesref are the coll. names (from param_filename) to select (if None take all).
        if power_loss_param is not None, compute (and print) the power loss (in W and W/m) for each element,
        using the parameters given in power_loss_param, which should be like
        [sigz(RMS in m),gamma,Nb(nb p+),M(nb of bunches)]
        (assumes Gaussian equidistant bunches and protons)
    
    LHC_many_holes(avbetax, avbetay, param_filename, beta_filename, fcutoff=5000000000.0, namesref=None, fpar=<Impedance.freq_param object>, zpar=<Impedance.z_param object>, power_loss_param=None)
        add up many axisymmetric elements with pumping holes into a single model.
        only longitudinal and dipolar terms are considered.
        avbetax and avbetay are the average beta functions
        used for the weighting, param_filename is the file with all parameters
        except betas, beta_filename the file with beta functions (in m).
        fcutoff is the cutoff frequency (from the beam pipe radius, default value=LHC).
        fpar selects the frequencies scan (object of the classes freq_param).
        namesref are the coll. names (from param_filename) to select (if None take all).
        if power_loss_param is not None, compute (and print) the power loss (in W and W/m) for each element,
        using the parameters given in power_loss_param, which should be like
        [sigz(RMS in m),gamma,Nb(nb p+),M(nb of bunches)]
        (assumes Gaussian equidistant bunches and protons)
    
    LHC_many_resonators(avbetax, avbetay, param_filename, beta_filename, beta=1, wake_calc=False, namesref=None, fpar=<Impedance.freq_param object>, zpar=<Impedance.z_param object>, power_loss_param=None)
        add up many resonators into a single model.
        each device is defined by an HOM file. 
        avbetax and avbetay are the average beta functions
        used for the weighting, param_filename is the file with all parameters
        except betas, beta_filename the file with beta functions (in m).
        beta is the relativistic velocity factor
        wake_calc selects the wake computation if True, fpar and zpar select the frequencies and
        distances (for the wake) scans (objects of the classes freq_param and z_param).
        namesref are the coll. names (from param_filename) to select (if None take all).
        if power_loss_param is not None, compute (and print) the power loss (in W and W/m) for each element,
        using the parameters given in power_loss_param, which should be like
        [sigz(RMS in m),gamma,Nb(nb p+),M(nb of bunches)]
        (assumes Gaussian equidistant bunches and protons)
    
    LHC_many_striplineBPMs(avbetax, avbetay, param_filename, beta_filename, beta=1, wake_calc=False, namesref=None, fpar=<Impedance.freq_param object>, zpar=<Impedance.z_param object>, power_loss_param=None)
        add up many stripline BPMS into a single model (using Ng simple fomulas).
        each device is defined by an HOM file. 
        avbetax and avbetay are the average beta functions
        used for the weighting, param_filename is the file with all parameters
        except betas, beta_filename the file with beta functions (in m).
        beta is the relativistic velocity factor
        wake_calc selects the wake computation if True, fpar and zpar select the frequencies and
        distances (for the wake) scans (objects of the classes freq_param and z_param).
        namesref are the coll. names (from param_filename) to select (if None take all).
        if power_loss_param is not None, compute (and print) the power loss (in W and W/m) for each element,
        using the parameters given in power_loss_param, which should be like
        [sigz(RMS in m),gamma,Nb(nb p+),M(nb of bunches)]
        (assumes Gaussian equidistant bunches and protons)
    
    LHC_manyelem_iw_model(E, avbetax, avbetay, param_filename, beta_filename, Bfield=None, wake_calc=False, ftypescan=2, nflog=100, namesref=None, power_loss_param=None, freq_dep_factor_file=None, dist_dep_factor_file=None, lxplusbatch=None, comment='', dire='')
        creates an impedance or wake model for many elements (cold beam screens
        and warm pipes).
        E is the energy in eV, avbetax and avbetay the average beta functions
        used for the weighting, param_filename is the file with all parameters
        except betas, beta_filename the file with beta functions (in m).
        nmat is the number of material layers -> look for columns 'material1' to 'material[nmat]'
        in the file param_filename, and for columns 'thickness1' to thickness[nmat-1]'
        
        Bfield: magnetic field (if None, compute it from the energy with LHC bending radius)
        
        wake_calc selects the wake computation if True, nflog is the number of frequencies
        per decade, and ftypescan the type of frequency scan (0,1 or 2: logarithmic only, 
        linear only or logarithmic with refinement around high-frequency resonance(s) ).
        
        namesref are the coll. names (from param_filename) to select (if None take all),
        
        if power_loss_param is not None, compute (and print) the power loss (in W and W/m) for each element,
        using the parameters given in power_loss_param, which should be like [sigz(RMS in m),Nb(nb p+),M(nb of bunches)]
        (assumes Gaussian equidistant bunches and protons)
        
        if freq_dep_factor_file is not None, each component is multiplied by a 
        frequency dependent factor, from the file indicated by this. File should
        contain (colums): frequency in Hz, then each component (factors for real
        part, then imaginary part), WITH HEADERS indicating the component (format:
        see function 'identify_component' in module Impedance + at the end re or 
        Re for real part and im or Im for imag. part).
        It is exactly the same for the wake with dist_dep_factor_file (if wake_calc==True).
        
        lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus on queue 'queue'
                       if 'retrieve' -> retrieve outputs
        dire contains the directory name where to put the outputs (default='./'=directory of IW2D)
    
###########
# HLLHC_imp

# a single function to compute the LH-LHC impedance model
# (it uses functions of LHC_imp.py and LHC_coll_imp.py)

FILE
    HLLHC_imp.py

FUNCTIONS
    HLLHC_imp_model_v2(E, avbetax, avbetay, param_filename_coll, settings_filename_coll, beta_filename_coll=None, TDIcoating='preLS1', dire='/afs/cern.ch/user/n/nmounet/scratch0/GIT_IRIS/IR...d_scripts/LHC_impedance_and_scripts/LHC_elements/', commentcoll='', direcoll='Coll_HLLHC_v2/', lxplusbatch=None, BPM=True, beam='1', squeeze='0p15m_round', wake_calc=False, ftypescan=0, nflog=100, zpar=<Impedance.z_param object>, optionCrab=None, optionBBC=0, margin_factor=1.0, optionMo_TCS37=None, optionTCu_triplet='', fcutoffBB=50000000000.0, flagplot=False, root_result='/afs/cern.ch/user/n/nmounet/scratch0/GIT_IRIS/IR...impedance_and_scripts/../../../DELPHI_results/LHC', commentsave='')
        Total HL-LHC impedance model as of Nov. 2013 (model v1 was actually
        the LHC model v1 with HL-LHC collimators and beta functions)
        - E: particle energy in eV
        - avbetax, avbetay: average beta function from smooth approximation (R/Q) in m
        - param_filename_coll: file with collimator parameters (including materials, 
          angle, length, beta functions)
        - settings_filename_coll: collimator settings file
        - beta_filename_coll: collimator beta functions file (if present - otherwise take param_filename_coll)
        - TDIcoating: kind of coatgin for first block of TDI: can be 'preLS1'
          (5mum Ti) or 'postLS1' (1mum NEG + 2mum CU + 0.3mum NEG + 5mum Ti) or 
          directly a list of layer objects
        - dire: directory where to find all files with parameters for the rest of the machine
        - commentcoll: comment for the collimators IW2D computation
        - direcoll: subdirectory of ImpedanceWake2D where to put collimators impedance
        - lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus
                       if 'retrieve' -> retrieve outputs
        - BPM: coll. geometry contains a BPM cavity if BPM is True, otherwise old LHC coll. geometry
        - beam: beam number ('1' or '2')
        - squeeze: suffix of filename with beta functions, for the rest of the 
        machine (everything except collimators). The first number gives the squeeze in IP1, 
        from which the broad-band impedance (from design report) is evaluated (squeezed if <2m,
        otherwise injection BB model is taken)
        - wake_calc: True to compute wake function as well
        - ftypescan, nflog and zpar: parameters for frequency and distance scans
        - optionCrab: None to put no crab cavities, or:
            '' to put crab cavities as 2 broad-band models,
            '_BNL' to put crab cavities as lsit of HOMS, for BNL kind of cavities,
            '_SLAC' to put crab cavities as lsit of HOMS, for SLAC kind of cavities,
        - optionBBC: 0 -> no beam-beam wire compensator,
                     1 -> beam-beam wire compensator as stand-alone wire (stripline BPM model),
                     2 -> beam-beam wire compensator embedded in tungsten collimator,
        - optionMo_TCS37: if not None, indicate Mo coating thickness on TCS collimators
        in IR3 and IR7,
        - option_TCu_triplet: if '', copper temperature in beam screen triplets is 20K, otherwise
        this temperature should be indicated (e.g. '50K' -> only case implemented now),
        - margin_factor: additional factor to take into account all the unknowns. 
            -> We multiply the final model by this value,
        - fcutoffBB: cutoff frequency for broad-band models,
        - flagplot: if True, plot impedances and percent of each part of the model,
        - root_result: used only with flagplot: directory where to put impedance plots,
        - commentsave: used only with flagplot: additional comment for filename of impedance plots.
    
##############
# LHC_coll_imp

# library of functions to compute impedance of collimators, including geometrical part (used by LHC_imp.py)
# NOTE: many parameters come from settings files, but some others are hard-corded
# (e.g. thickness of jaws, TDI coating and blocks info, etc.)
#
# most useful function:  LHC_manycoll_iw_model_with_geom (provides the model for a full list of collimators)


FILE
    LHC_coll_imp.py

FUNCTIONS
    LHC_manycoll_iw_model(E, avbetax, avbetay, param_filename, settings_filename, beta_filename, wake_calc=False, ftypescan=2, nflog=100, namesref=None, coatingmat=None, coatingthickness=0, lxplusbatch=None, comment='', dire='')
        creates an impedance or wake model for all collimators.
        E is the energy in eV, avbetax and avbetay the average beta functions
        used for the weighting, param_filename is the file with all parameters
        except half-gaps and betas, settings_filename is the file with half-gaps (in m),
        beta_filename the file with beta functions (in m).
        wake_calc selects the wake computation if True, nflog are the number of frequencies
        per decade, and ftypescan the type of frequency scan (0,1 or 2: logarithmic only, 
        linear only or logarithmic with refinement around high-frequency resonance(s) ).
        namesref are the coll. names (from param_filename) to select (if None take all),
        coatingmat and coatingthickness is the info about an added coating.
        lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus on queue 'queue'
                       if 'retrieve' -> retrieve outputs
        dire contains the directory name where to put the outputs (default='./'=directory of IW2D)
    

    LHC_manycoll_iw_model_with_geom(E, avbetax, avbetay, param_filename, settings_filename, beta_filename, wake_calc=False, ftypescan=2, nflog=100, zpar=<Impedance.z_param object>, namesref=None, coatingmat=None, coatingthickness=0, TDIcoating='postLS1', BPM=False, flag_wakefiles=False, fcutoffBB=5000000000.0, lxplusbatch=None, comment='', dire='', assymetry_factor_TCL6=1.0)
        creates an impedance or wake model for all collimators.
        E is the energy in eV,
        avbetax and avbetay the average beta functions used for the weighting,
        param_filename is the file with all parameters except half-gaps and betas,
        settings_filename is the file with half-gaps (in m),
        beta_filename the file with beta functions (in m),
        wake_calc selects the wake computation if True.
        nflog is the number of frequencies per decade,
        ftypescan the type of frequency scan (0,1 or 2: logarithmic only, 
        linear only or logarithmic with refinement around high-frequency resonance(s) ).
        zpar gives the distance scan for the wake.
        namesref are the coll. names (from param_filename) to select (if None take all),
        coatingmat and coatingthickness is the info about an added coating (material
        name + thickness or layer object directly in coatingmat).
        TDIcoating indicates kind of coatgin for first block of TDI: can be 'preLS1'
        (5mum Ti) or 'postLS1' (1mum NEG + 2mum CU + 0.3mum NEG + 5mum Ti) or directly
        a list of layer objects
        BPM: geometry contains a BPM cavity if BPM is True, otherwise old LHC coll. geometry
        flag_wakefiles: True to use GdFidl wake potential files instead of Stupakov
        
        fcutoffBB: cutoff frequency for broad-band model of geometric impedance
        of collimators
        
        lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus on queue 'queue'
                       if 'retrieve' -> retrieve outputs
        dire contains the directory name where to put the outputs (default='./'=directory of IW2D)
        
        assymetry_factor_TCL6: assymetry factor between the distance beam-jaw
        in the case of the TCL6 (1 means that jaws are symmetric).
        
        In this version, the parameter file can contain several material columns
        (with the associated thickness columns) and the geometric impedance is 
        taken into account
    
    LHC_TDI_iw_model(name, material, halfgap, angle, gamma, wake_calc=False, TDIcoating=['Ti_in_TDI', None, None], TDIcoatingthickness=[5.0000000000000004e-06, 0, 0], ftypescan=2, nflog=100, lxplusbatch=None, comment='', dire='')
        impedance/wake model for the LHC TDI (particular case: 3 blocks)
        lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus on queue 'queue'
                       if 'retrieve' -> retrieve outputs
        dire contains the directory name where to put the outputs (default='./'=directory of IW2D)
    

    LHC_TDI_iw_model_with_geom(name, halfgap, angle, gamma, wake_calc=False, TDIcoating='postLS1', ftypescan=2, nflog=100, zpar=<Impedance.z_param object>, flag_wakefiles=False, fcutoffBB=5000000000.0, lxplusbatch=None, comment='', dire='')
        impedance/wake model for the LHC TDI (particular case: 3 blocks)
        TDIcoating: for first block it can be 'preLS1' (5mum Ti) or 'postLS1'
        (1mum NEG + 2mum CU + 0.3mum NEG + 5mum Ti) or directly a list of
        layer objects
        flag_wakefiles: True to use GdFidl wake potential files instead of Stupakov
        
        fcutoffBB: cutoff frequency for broad-band model of geometric impedance
        of collimators
        
        lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus on queue 'queue'
                       if 'retrieve' -> retrieve outputs
        dire contains the directory name where to put the outputs (default='./'=directory of IW2D)
        
        In this version geometric impedance is taken into account (SAME AS FOR
        TCS coll -> BIG WARNING !!!)
    


    LHC_singlecoll_iw_model(name, material, halfgap, angle, gamma, length, wake_calc=False, coatingmat=None, coatingthickness=0, fpar=<Impedance.freq_param object>, zpar=<Impedance.z_param object>, lxplusbatch=None, comment='', dire='', queue=None)
        construct impedance/wake model (flat chamber) for an LHC collimator 
        with a skew angle (as defined in N. Mounet PhD, p. 56)
        name is the name of the collimator, material its main material,
        angle in rad, halfgap in m
        wake_calc: flag for wake calculation
        if coatingmat is not None, first layer is a coating defined
        by this and coatingthickness
        last layer is always stainless steel 304L
        
        fpar and zpar select the frequencies and distances (for the wake) scans 
        (objects of the classes freq_param and z_param).
        
        lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus on queue 'queue'
                       if 'retrieve' -> retrieve outputs
        comment is added to the name for IW2D output files
        dire contains the directory name where to put the outputs (default='./'=directory of IW2D)
        if queue is not None, it is the lxbatch queue where to launch the calculation.
    

    LHC_singlecoll_iw_model_with_geom(name, materials, halfgap, angle, gamma, length, thickness=[], wake_calc=False, fpar=<Impedance.freq_param object>, zpar=<Impedance.z_param object>, BPM=False, flag_wakefiles=False, fcutoffBB=5000000000.0, lxplusbatch=None, comment='', dire='', queue=None, assymetry_factor=1.0)
        construct impedance/wake model (flat chamber) for an LHC collimator 
        with a skew angle (as defined in N. Mounet PhD, p. 56)
        name is the name of the collimator, materials its materials
        (list of names or layer objects), angle in rad, halfgap in m,
        layers thickness in m except the last (and main) jaw material (e.g. CFC, hBN, etc.)
        which is hard-coded.
        geometry contains a BPM cavity if BPM is True, otherwise old LHC coll. geometry
        wake_calc: flag for wake calculation
        This includes geometric impedance from Stupakov's analytical formula
        (flat tapers), thanks to INFN computations (M. Zobov, O. Frasciello)
        
        last layer is always stainless steel 304L
        
        fpar and zpar select the frequencies and distances (for the wake) scans 
        (objects of the classes freq_param and z_param).
        
        flag_wakefiles: True to use GdFidl wake potential files instead of Stupakov
        
        fcutoffBB: cutoff frequency for broad-band model of geometric impedance
        of collimators
        
        lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus on queue 'queue'
                       if 'retrieve' -> retrieve outputs
        comment is added to the name for IW2D output files
        dire contains the directory name where to put the outputs (default='./'=directory of IW2D)
        if queue is not None, it is the lxbatch queue where to launch the calculation.
        if assymetry factor is different from 1, uppper & lower jaws are not at the same
        distance from the beam, and assymetry_factor represents the factor applied to
        the distance to the upper jaw to get that of the lower jaw (can be zero - no lower
        jaw, as in TCDQ)
    
    
    read_coll_files(param_filename, settings_filename, beta_filename, namesref=None)
        read collimator files and output parameters.
    
    read_coll_files_several_mat(param_filename, settings_filename, beta_filename, namesref=None)
        read collimator files and output parameters. Version with
        possibility to have several material columns (with the associated
        thickness columns)
    
    select_LHC_coll_IR(names, pattern='', IRlist=[1, 2, 3, 4, 5, 6, 7, 8])
        select from a list of LHC device names those that begin with "pattern" and that are in
        an IR in the list "IRlist" (from 1 to 8)
        By default, pattern and IRlist are such that all names are
        selected.
    

#################################################################################
# LHC parameters & settings								#
#################################################################################

###########
# LHC_param

# function to provide general LHC parameters

FILE
    LHC_param.py

FUNCTIONS
    LHC_param(E0, E=7000000000000.0)
	generate typical LHC parameters, given the proton rest energy E0 in J (from e.g. function
	proton_param) and the beam energy E in eV.
	Outputs:
	- machine: string with machine name,
	- E: same as input (beam energy in eV),
	- gamma: relativistic mass factor,
	- sigmaz: RMS bunch length in m,
	- taub: total bunch length in s (4*RMS),
	- R: machine pysical radius (circumference/(2 pi)),
	- Qx: total horizontal tune (integer + fractional parts),
	- Qxfrac: fractional horizontal tune,
	- Qy: total vertical tune (integer + fractional parts),
	- Qyfrac: fractional vertical,
	- Qs: synchrotron tune,
	- eta: slippage factor (alpha_p-1/gamma^2),
	- f0: revolution frequency,
	- omega0: revolution angular frequency=2pi*f0,
	- omegas: synchrotron angular frequency=Qs*omega0,
	- dphase: phase of damper w.r.t. "normal" purely resistive damper,
	- Estr: string with energy (e.g. '7TeV', '450GeV', etc. - see below),
	- V: RF voltage in V,,
	- h: harmonic number.
    
#############
# Folders LHC_elements/ and Coll_settings/

# Those are folders containing all the LHC & HL-LHC machine elements parameters and settings,
# used to compute the impedances (collimators half-gaps, materials, all beta functions, HOMs, 
# bean screen and pipe cross sections, pumping holes dimenstions, etc.)


#################################################################################
# Script examples
#################################################################################

# All the other python files here are scripts that can be run from the command line,
# performing certain kinds of Impedance and/or DELPHI computations.
#
# They have to be taken as mere examples; in particular, the oldest ones 
# do not use the latest and highest level DELPHI wrapping functions and can be quite
# inefficient, or even crash. For instance, some might look for HEADTAIL simulation
# files which are local files in N. Mounet workspace; you have to comment/take out
# the corresponding lines (see also below).

# In principle a new script has to be done for any new kind of computation, and these
# examples can serve as starting points.

# If one wants to launch a test, the simplest and also one of the most recent scripts are

LHC_compare.py
LHC_tuneshift.py
#(see descriptions below)

# Then the most recent script for the LHC impedance model predictions (including stability
limits) is:
LHC_new_postLS1.py

# For HL-LHC it is:
LHC_HLLHC_new_comp_imp.py

# To launch the scripts on a LSF batch system (like lxplus), the procedure is
# (e.g. here with LHC_compare):
# first type
./LHC_compare.py launch launch
#
# -> this launches the resistive-wall impedance computations on batch jobs
#
# then when all jobs are finished (and if none crashed)
./LHC_compare.py retrieve launch
#
# -> this retrieves the resistive-wall impedance computations, computes the impedance model
# (can still takes a bit of time) and finally launches the DELPHI computations
# to get instabilities complex tune shifts. Note that if some computations were already done
# (in a previous 'launch'), only computations that were not already performed
# (i.e. for which there is not the file 'outpickle_[name_of_the_computation]' already
# present in the 'root_result' folder - see below) are launched.
#
# Finally, when all jobs are finished: 
./LHC_compare.py retrieve retrieve
#
# -> this will finally write output files and plots (depending on the scripts).
#
# Note: sometimes there will be a warning, saying that some 'outpickle[...]' file is missing
# The code can still retrieve the results (there will simply be some missing points in the plots...).
# So it is a problem only if too many of such warnings happen, which would mean there is
# a more serious issue (e.g. queue on lxbatch is too short, or computations failed for
# some reason).

# In all these scripts results are put in the folder 'root_result', that is most of the time: 
# ../../../DELPHI_results/[machine_name]/[some_name_related_to_the_script]
# You can change this folder at the beginning of the script.

# Scripts are ~always structured as followed:
# - parameters and scanned parameters definition
# - impedance model computation
# - DELPHI computation (sometimes with Sacherer also)
# - plots of results (typically growth_rate vs Q' or vs. intensity, TMCI plots, or stability limis).

##########
# Typical variables that are very often used (see also LHC parameters described above in LHC_param function)
# in these scripts examples:

- beam='1' -> '1' for beam 1, '2' for beam 2
- root_result: directory where to put the results
- flagnorm (always 0): 1 if damper matrix normalized at current chromaticity; 0
  if instead it is normalized at zero chroma (which I almost always assume)
- strnorm (always ['','_norm_current_chroma']): (this never changes...) list with 2 strings:
  at the end of all output files, the string strnorm[flagnorm] is added (it is more or less useless...)
- flagsave: 1 to save figures in .png and .eps files, instead of plotting on screen (0 to plot on screen 
  -> very dangerous since there can be many many plots...)
- flagdamperimp (always 0): 1 to use frequency dependent damper gain (that you have to provide in Zd,fd),
  0 to use a bunch-by-bunch damper
- flagplot: True to plot all impedances during impedance model generation, otherwise False
  (see above in LHC_imp functions) 
- nevery: downsampling of the impedance (take less points than in the full model);
  useful for LHC & HL-LHC v2 models that contain a bit too many points...
- wake_calc: True -> compute wake as well (otherwise only impedance)
- kmax: number of converged eigenvalues in DELPHI convergence process (kmax most unstable ones are 
converged within at worst 5%) -> kmax=1 is enough when we look only at most unstable mode
- kmaxplot: number of kept and plotted eigenvalues (in TMCI plot)
- g,a,b: longitudinal distribution parameters, usually from longdistribution_decomp function (from DELPHI.py) 

- scan definition:
    
    Scans on impedance model parameters (all these scans have same length -> all arrays are corresponding
    to each others):
    * scenarioscan
    * dircollscan
    * legscen
    * squeezescan
    * Escan
    * subscan: subscan of the 5 previous, to select only a few scenarios in the previous without
    redefining everything
    * strsubscan: string to be added to general plots with all these scenarios
    * margin_factor (always 1): factor by which ones multiply all impedances (never used now)
    
    Scans on beam & machine parameters (all these scans are typically done on top of each others ->
    can make up many many calculations - but remember that intensity scan, damper gain and phase scans, and Qs scans
    take no time)
    * Qpscan: scan in chromaticity Q'
    * Qpaver: chromaticities used of final stability limit (in the foreseen scenario)
    * Qpscanplot: chromaticities for which we do plot vs intensity and/or TMCI plots 
    * dampscan: damper gain scan (in 1/number_of_damping_turns)
    * Nbscan: intensity scan (number of particles per bunch)
    * Nbscanplot: intensities for which we do plots vs Qp
    * NbscanHEADTAIL[...]: intensities for which we do a comparison vs HEADTAIL
    NOTE: this typically requires access to N. Mounet local files, so you have to deactivate this by 
    making the array empty
    * Mscan: scan on total number of bunches.


- tuneshiftQp: array of complex tuneshifts with all results, for all scanned parameters and all kmaxplot modes kept
- tuneshiftm0Qp: array of complex tuneshifts for mode 0 only, for all scanned parameters
- imp_mod: full impedance model (list of components, which are impedance_wake objects from the
impedance library in Impedance.py)
- imp_mod_list: complete list of impedance scenarios (list of impedance models)
- wake_mod and wake_mod_list: same but for wake functions.


###########
# Short description of each script (we indicate if the script is old so not using the latest 
# library functionalities or even likely to crash)

  HLLHC_coll_details.py
  	plots contribution of each collimator (RW, geometric, and both) 
	vs total HL-LHC model, in terms of complex tuneshifts and kick factor
 
  HLLHC_HOM_test.py
  	scan HOM parameters (R, f and Q), add on top of HL-LHC model and see the effect
	in terms of TMCI threshold, coupled-bunch modes and single-bunch (damper + high Q') growth rates

  HLLHC_triplets_BS_details.py
  	Recent script to look at the details of the impedance in the triplet region (IR 1 & 5) in HL-LHC
  	
  LHC_BS_TMCI.py
  	computes the TMCI threshold from the resistive-wall impedance of the beam screens alone

  LHC_coll_details.py
  	plots contribution of each collimator (RW, geometric, and both) 
	vs total LHC model, in terms of complex tuneshifts and kick factor

  LHC_coll_family_details.py
  	plots contribution of each collimator family (TCP, TCS, TCT, TCL, etc.) 
	in the total LHC impedance model

  LHC_coll_meas_comp.py
  	compare tuneshifts from DELPHI, HEADTAIL and measured in MD when moving
	some collimator families in and out

  LHC_compare_impedances.py
  	compare between them 2 cases (one 2011 experiment and a typical 2012 case),
	with different beam & machine settings (including different collimator settings
	and different damper settings), in terms of impedance & complex tuneshifts

  LHC_conv_for_Simon.py 
  	just a computation of complex tuneshifts vs Q' in a certain LHC configuration, using
	the zbase impedance model (so only one launch/retrieve possible - the one for DELPHI, not 2)

  LHC_conv_postLS1.py (old)
  	first script to compute post-LS1 stability limits

  LHC_conv.py (very old)
  	one of the very first scripts to compute (converged) complex tuneshifts from DELPHI
	using the zbase impedance model (not using lxplus batch system)

  LHC_conv_testTCTPmode.py (very old)
	Find the impact of adding a strong ~100MHz mode from the TCTP collimators (found out 
	in simulations by B. Salvant) on top of the LHC impedance (from zbase). This script
	does not use the lxplus batch system
    	
    	It also contains 2 functions to compute the TCTP mode impedance:

	TCTP_modes(scenario=0)
	    retrieve the TCTP low freq. modes parameters (resonance frequencies, shunt impedances
	    and quality factor), and the collimator settings (half-gaps and beta functions)
	    scenario is the TCT settings & beta functions scenario (from Roderik Bruce):
    		0 = first realistic (small beta*),
    		1 = second realistic (large beta*),
    		2 = first pessimistic (8 sigmas, beta*=0.55 m),
    		3 = second pessimistic (12 sigmas, beta*=1.5 m).
	
	TCTP_modes_impedance(betaavx, betaavy, nmodes=1, scenario=0, flagplot=True)
	    compute TCTP low freq. modes impedance
	    betaavx and betaavy are the average betas taken for the beta function weighting (usually circ/(2*pi*tune) ),
	    nmodes is the number of resonances taken into account (up to 5), scenario is the
	    TCT settings & beta functions scenario (from Roderik Bruce):
    		0 = first realistic (small beta*),
    		1 = second realistic (large beta*),
    		2 = first pessimistic (8 sigmas, beta*=0.55 m),
    		3 = second pessimistic (12 sigmas, beta*=1.5 m).
	    plot total modes impedance only when flagplot is True.
    
  LHC_wake_withTCTPmode.py
  	Computes the effect of the TCTP mode on the wake. Also contains the function:

	TCTP_modes_wake(wakefile, betaavx, betaavy, nmodes=1, scenario=0)
	    compute TCTP low freq. modes wake function and add to the wake in wakefile
	    betaavx and betaavy are the average betas taken for the beta function weighting (usually circ/(2*pi*tune) ),
	    nmodes is the number of resonances taken into account (up to 5), scenario is the
	    TCT settings & beta functions scenario (from Roderik Bruce):
    		0 = first realistic (small beta*),
    		1 = second realistic (large beta*),
    		2 = first pessimistic (8 sigmas, beta*=0.55 m),
    		3 = second pessimistic (12 sigmas, beta*=1.5 m).'''

  LHC_HLLHC_comp_imp.py (old)
  	First script done to compare LHC and HL-LHC and plotting the stability limits
	for HL-LHC.

  LHC_HLLHC_new_comp_imp.py
  	Most recent script to compute HL-LHC stability limits.

  LHC_HLLHC_triplets_imp.py (old)
  	First script done to compare LHC & HL-LHC impedance in the triplets and to check
	the various contributions.

  LHC_kickfactor_coll.py
  	Compares kick factors for collimators from M. Zobov (gemoetric) and from analytic formulae (RW).
	It also	computes some complex tuneshifts (DELPHI, Sacherer and MOSES - using for the latter
	the MOSES wrapper of DELPHI.py)

  LHC_new_postLS1.py
  	Most recent script to compute post-LS1 stability limits (was used for Evian 2014),
	including many scans (Q', intensity, damper)

  LHC_new_postLS1_bunchlength_Qs_tests.py
  	Tests effect of bunch length & Qs on TMIC threshold on growth rates (vs Q' / intensity)
	for post-LS1 scenarios
  	
  LHC_new_postLS1_test_betabeatIR7.py
  	Test the effect of beta beating introduced in IR7 to lower the impedance
	on growth rates, in some post-LS1 configuration.

  LHC_notconv.py (very old)
	Very first script to compute complex tuneshift (NOT converged) with the DELPHI library.  	

  LHC_optim_coll_IR3_IR7.py
	Most recent script to test the effect of relaxing / tightening the collimator
	settings in IR3 and IR7, on stability limits.

  LHC_optim_coll_IR3.py
  	First trial to check the effect on impedance of relaxing / tightening IR3 collimators.
	Also outputs the relative contribution of IR3 vs total collimator impedance

  LHC_optim_coll.py (old)
  	First script to check post-LS1 scenarios on impedance and tune shifts (old LHC model).

  LHC_test_a.py
  	Scan of the 'a' parameter (in initial longitudinal distribution) and see impact on
	growth rates vs Q' & TMCI (for HL-LHC)

  LHC_test_fcutoff.py
  	Scan of the cutoff frequency chosen for the broad-band part of the LHC imp. model
	and see impact on growth reates vs Q' & TMCI (for HL-LHC)

  LHC_test_Mo_coll.py (old)
  	Test the impact on total impedance of Molybdenum collimators (old LHC model).

  LHC_test_somedeviceIR3_coating.py
  	Test the impact of coating on one device on the total impedance (old LHC model).

  LHC_test_TCDQ_coating.py
  	Test the impact of coating the TCDQ on its growth rate vs Q', and its power loss.

  LHC_test_TCL4_coll.py
  	Test the impact on total impedance of TCL4 collimators (old LHC model).  	

  LHC_test_TCRYO_coll.py
  	Test the impact on total coll. impedance of TCRYO collimators (old LHC model).

  LHC_test_TDI_coating.py
  	Test impact of new (5 layers) coating on hBN in TDI, on total impedance (old LHC model),
	and effect on growth rates and kick factor.

  LHC_triplets_imp_OLD.py (old)
  	Old script to check the various contributions in the LHC triplets (impedance and
	complex tuneshifts)

  LHC_tuneshift.py (VERY SIMPLE AND RECENT)
  	Very simple and recent script to compute real tuneshifts of mode 0, vs Q', in a single case
	(from sum Zdip+Zquad).

